// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  (function(root, factory) {
    var Iterator, List;
    if (typeof define === 'function' && define.amd) {
      return define(['../../bin/iterator', '../../bin/list'], factory);
    } else if (typeof exports === 'object') {
      Iterator = require('../../src/iterator.coffee');
      List = require('../../src/list.coffee');
      return module.exports = factory(List);
    } else {
      Iterator = root.Mimosas.Iterator;
      List = root.Mimosas.List;
      return factory(Iterator, List);
    }
  })(this, function(Iterator, List) {
    describe('List', function() {
      var makeIterator;
      return makeIterator = function() {
        var item, items, iterator, list, _i, _len;
        items = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        list = new List();
        iterator = new Iterator(list);
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          list.append({
            __POINTER__: item
          });
        }
        return {
          iterator: iterator,
          list: list
        };
      };
    });
    return {
      'should exist': function(test) {
        test.equal(Iterator != null, true);
        return test.done();
      },
      'should be done when list is empty': function(test) {
        var iterator, list, _ref;
        _ref = makeIterator(), iterator = _ref.iterator, list = _ref.list;
        test.equal(iterator.isDone(), true);
        return test.done();
      },
      'should throw when next is called on an empty list': function(test) {
        var iterator, list, _ref;
        _ref = makeIterator(), iterator = _ref.iterator, list = _ref.list;
        test.throws(function() {
          iterator.next();
          return iterator.currentItem();
        });
        return test.done();
      },
      'should not be done when created with a list that has one item': function(test) {
        var iterator, list, _ref;
        _ref = makeIterator('foo'), iterator = _ref.iterator, list = _ref.list;
        test.equal(iterator.isDone(), false);
        return test.done();
      },
      'should be done after calling next on a list that has one item': function(test) {
        var iterator, list, _ref;
        _ref = makeIterator('foo'), iterator = _ref.iterator, list = _ref.list;
        iterator.next();
        test.equal(iterator.isDone(), true);
        return test.done();
      },
      'should get the correct item after calling next': function(test) {
        var item, iterator, list, _ref;
        _ref = makeIterator('foo', 'bar'), iterator = _ref.iterator, list = _ref.list;
        iterator.next();
        item = iterator.currentItem();
        test.equal(item.__POINTER__, 'bar');
        return test.done();
      },
      'should be done after removing all items from list': function(test) {
        var iterator, list, _ref;
        _ref = makeIterator('foo', 'bar'), iterator = _ref.iterator, list = _ref.list;
        list.removeAll();
        test.equal(iterator.isDone(), true);
        return test.done();
      },
      'should go back to the first item': function(test) {
        var item, iterator, list, _ref;
        _ref = makeIterator('foo', 'bar'), iterator = _ref.iterator, list = _ref.list;
        iterator.next().first();
        item = iterator.currentItem();
        test.equal(item.__POINTER__, 'foo');
        return test.done();
      },
      'should throw when getting an item that is out of bounds': function(test) {
        var iterator, list, _ref;
        _ref = makeIterator('foo'), iterator = _ref.iterator, list = _ref.list;
        iterator.next();
        test.throws(function() {
          iterator.next();
          return iterator.currentItem();
        });
        return test.done();
      }
    };
  });

}).call(this);
